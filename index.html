<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è·³æ£‹æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 20px;
        }
        
        header {
            text-align: center;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        canvas {
            background-color: #f0f0f0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: block;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #undoBtn {
            background-color: #3498db;
            color: white;
        }
        
        #undoBtn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        
        #restartBtn {
            background-color: #e74c3c;
            color: white;
        }
        
        #restartBtn:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            background-color: #ecf0f1;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .instructions {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            border-radius: 8px;
            margin-top: 25px;
            max-width: 800px;
        }
        
        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
            color: #555;
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .victory-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(46, 204, 113, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .legend-text {
            font-size: 0.9rem;
            color: #555;
        }
        
        .victory-area-label {
            margin-top: 10px;
            padding: 8px 15px;
            background: linear-gradient(90deg, rgba(144, 238, 144, 0.3), rgba(60, 179, 113, 0.3));
            border-radius: 20px;
            font-size: 0.9rem;
            color: #2e8b57;
            font-weight: 600;
            border: 2px dashed #3cb371;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            canvas {
                width: 95vw;
                height: auto;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }

        /* Toast æ ·å¼ */
        #toastContainer {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
            pointer-events: none;
        }
        .toast {
            min-width: 180px;
            max-width: 320px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 10px 14px;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            font-weight: 600;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .toast.success { background: linear-gradient(90deg,#2ecc71,#27ae60); }
        .toast.error { background: linear-gradient(90deg,#e74c3c,#c0392b); }
        .toast.info { background: rgba(0,0,0,0.8); }
        .toast .toast-message { flex: 1; margin-right: 8px; font-weight:600; }
        .toast .toast-close { cursor: pointer; opacity: 0.9; padding-left: 8px; }
        /* å¸ƒå±€ï¼šæ°´å¹³æ’åˆ—é¢æ¿ä¸ä¸»å®¹å™¨å¹¶å±…ä¸­ */
        .layout-row {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 18px;
            width: 100%;
            box-sizing: border-box;
        }
        .panel {
            width: 280px;
            background: transparent;
            padding: 12px 14px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <header>
        <h1>è·³æ£‹æ¸¸æˆ</h1>
    </header>
    
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="gameCanvas" width="800" height="700"></canvas>
                <div class="victory-message" id="victoryMessage">ğŸ‰ èƒœåˆ©ï¼æ£‹å­å·²åˆ°è¾¾é¡¶éƒ¨ï¼</div>
                <div id="genSpinner" style="display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:200;align-items:center;gap:10px;padding:12px 16px;border-radius:8px;background:rgba(0,0,0,0.65);color:#fff;font-weight:600;">
                    ç”Ÿæˆä¸­â€¦
                </div>
            </div>
            
            <div class="controls">
                <button id="undoBtn">æ’¤é”€ (Ctrl+Z)</button>
                <button id="restartBtn">é‡æ–°å¼€å§‹</button>
                <button id="regenBtn">é‡æ–°ç”Ÿæˆåœ°å›¾</button>
                <!-- åœ°å›¾ä¸‹æ‹‰å·²ç§»é™¤ -->
                <!-- å·²ç§»é™¤è·¯å¾„é«˜äº®æ§åˆ¶ -->
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">ç§»åŠ¨æ­¥æ•°</div>
                    <div class="stat-value" id="moveCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å‰©ä½™æ£‹å­</div>
                    <div class="stat-value" id="remainingPieces">28</div>
                </div>
            </div>
        </div>
    </div>
    <div id="toastContainer"></div>

    <script>
        // ç®€å• toast å·¥å…·
        function showToast(message, { type = 'info', duration = 2500, persist = false } = {}) {
            const container = document.getElementById('toastContainer');
            if (!container) return null;
            const id = 'toast-' + Date.now() + '-' + Math.floor(Math.random()*1000);
            const el = document.createElement('div');
            el.className = 'toast ' + (type || 'info');
            el.id = id;
            el.innerHTML = `<div class="toast-message">${message}</div><div class="toast-close">âœ•</div>`;
            container.appendChild(el);

            const closeFn = () => { if (el.parentNode) el.parentNode.removeChild(el); };
            el.querySelector('.toast-close').addEventListener('click', closeFn);

            if (!persist) {
                setTimeout(() => { closeFn(); }, duration);
            }

            return id;
        }

        function hideToast(id) {
            const el = document.getElementById(id);
            if (el && el.parentNode) el.parentNode.removeChild(el);
        }

        // å›ºå®šåœ°å›¾å·²ç§»é™¤ â€” æ¯æ¬¡åŠ è½½å°†ä½¿ç”¨ç”Ÿæˆå™¨éšæœºç”Ÿæˆå¯èƒœåˆ©åœ°å›¾
        // -----------------------------------------------------
        // æ¸¸æˆå¸¸é‡
        // -----------------------------------------------------
        const ROWS_LAYOUT = [1, 2, 3, 4, 13, 12, 11, 10, 9, 10, 11, 12, 13, 4, 3, 2, 1];
        const BOARD_ROWS = ROWS_LAYOUT.length;
        const BOARD_COLS = 17;
        const INVALID = -1;
        const EMPTY = 0;
        const OBSTACLE = 1;
        const PLAYER = 2;
        
        // å…­æ–¹å‘å‘é‡ï¼ˆè½´å‘åæ ‡ï¼‰
        const AXIAL_DIRS = [
            [1, 0], [1, -1], [0, -1], 
            [-1, 0], [-1, 1], [0, 1]
        ];
        
        // é¢œè‰²å®šä¹‰
        const COLORS = {
            BG: '#f0f0f0',
            EMPTY: '#e8e8e8',
            PLAYER: '#00C853',
            SELECTED: '#FFB350',
            HIGHLIGHT: '#78FF78',
            WIN_AREA: 'rgba(60, 179, 113, 0.3)',
            WIN_AREA_BG: 'rgba(144, 238, 144, 0.1)',
            WIN_AREA_BORDER: 'rgba(60, 179, 113, 0.6)',
            PURPLE: '#A020F0',
            PINK: '#FF69B4',
            YELLOW: '#FFD700',
            ORANGE: '#FF8C00',
            RED: '#DC143C',
            BLUE: '#3282FF'
        };
        
        // -----------------------------------------------------
        // æ¸¸æˆç±»
        // -----------------------------------------------------
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.board = null;
                this.boardColors = null;
                this.playerPos = null;
                this.indexToAxial = new Map();
                this.axialToIndex = new Map();
                this.selected = null;
                this.moveCount = 0;
                this.history = [];
                this.gameWon = false;
                this.remainingPieces = 28;
                
                this.initGame(true);
                this.setupEventListeners();
                this.draw();
            }
            
            initGame(isFirstInit = false) {
                // æ¸…ç©ºå†å²è®°å½•ï¼ˆé™¤éæ˜¯ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼‰
                if (!isFirstInit) {
                    this.history = [];
                }
                
                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                this.setupBoard();
                this.moveCount = 0;
                this.remainingPieces = 28;
                this.gameWon = false;
                this.selected = null;
            }
            
            createEmptyBoard() {
                const board = Array(BOARD_ROWS).fill().map(() => Array(BOARD_COLS).fill(INVALID));
                for (let r = 0; r < BOARD_ROWS; r++) {
                    const count = ROWS_LAYOUT[r];
                    const offset = Math.floor((BOARD_COLS - count) / 2);
                    for (let i = 0; i < count; i++) {
                        const c = offset + i;
                        board[r][c] = EMPTY;
                    }
                }
                return board;
            }
            
            createEmptyColorLayer() {
                return Array(BOARD_ROWS).fill().map(() => Array(BOARD_COLS).fill(null));
            }
            
            logicalToIndex(rowNo, posNo) {
                const r = rowNo - 1;
                if (r >= 0 && r < BOARD_ROWS) {
                    const count = ROWS_LAYOUT[r];
                    const offset = Math.floor((BOARD_COLS - count) / 2);
                    const c = offset + (posNo - 1);
                    if (c >= 0 && c < BOARD_COLS) {
                        return [r, c];
                    }
                }
                return null;
            }
            
            setupBoard() {
                return new Promise((resolve, reject) => {
                // è®¾ç½®éšœç¢ç‰©ï¼ˆç›´æ¥ä½¿ç”¨ç”Ÿæˆå™¨ï¼‰
                // ä½¿ç”¨ç”Ÿæˆå™¨åˆ›å»ºåœ°å›¾ï¼ˆè¯»å– UI éš¾åº¦/å‚æ•°ï¼‰
                const diffEl = document.getElementById('difficultyRange');
                const diff = diffEl ? parseInt(diffEl.value || '3', 10) : 3;
                // æ˜ å°„ï¼šdifficulty -> minDirChanges, maxStraight, decorationDensity
                const options = {
                    maxSteps: 12,
                    maxAttempts: 200,
                    minDirChanges: Math.max(1, diff),
                    maxStraight: Math.max(1, 3 - Math.floor((diff-1)/2)),
                    allowLongJumps: false,
                    decorationDensity: Math.max(0, 0.06 - (diff-1)*0.01)
                };

                const applyObstacles = (obstacles) => {
                    this.generatedPathIndices = [];
                    obstacles = obstacles || [];
                    obstacles.forEach(([row, pos, color]) => {
                        const posIdx = this.logicalToIndex(row, pos);
                        if (posIdx) {
                            const [r, c] = posIdx;
                            this.board[r][c] = OBSTACLE;
                            this.boardColors[r][c] = color;
                            this.generatedPathIndices.push([r, c]);
                        }
                    });
                    this.remainingPieces = this.generatedPathIndices.length;

                    // è®¾ç½®ç©å®¶å¹¶å®Œæˆåç»­åˆå§‹åŒ–
                    const playerPos = this.logicalToIndex(17, 1);
                    if (playerPos) {
                        const [r, c] = playerPos;
                        this.board[r][c] = PLAYER;
                        this.playerPos = [r, c];
                    }

                    this.createAxialMapping();
                    this.moveCount = 0;
                    // å°†å½“å‰ç”Ÿæˆçš„åœ°å›¾è®¾ä¸ºæ–°çš„åˆå§‹çŠ¶æ€ï¼šé‡ç½®å†å²ä¸ºä»…åŒ…å«æ­¤çŠ¶æ€
                    const initState = {
                        board: this.board.map(row => [...row]),
                        boardColors: this.boardColors.map(row => [...row]),
                        playerPos: this.playerPos ? [...this.playerPos] : null,
                        moveCount: this.moveCount,
                        remainingPieces: this.remainingPieces
                    };
                    this.history = [initState];
                    this.updateUI();
                    this.draw();
                };

                // å¦‚æœæœ‰ workerï¼Œåˆ™å¼‚æ­¥ç”Ÿæˆ
                if (window.genWorker) {
                    const worker = window.genWorker;
                    const requestId = Date.now() + Math.random();
                    // request generation
                    const spinner = document.getElementById('genSpinner');
                    if (spinner) spinner.style.display = 'flex';

                    const handler = (e) => {
                        const d = e.data;
                        if (d && d.requestId && d.requestId !== requestId) return;
                        if (!d || !d.type) return;
                        // worker message
                        // ignore progress messages (no debug/progress UI required)
                        if (d.type === 'progress') return;

                        if (d.type === 'result') {
                            // worker result
                            if (spinner) spinner.style.display = 'none';
                            worker.removeEventListener('message', handler);
                            const obstacles = d.obstacles || [];
                            if (obstacles.length === 0) {
                                // worker returned empty obstacles, falling back to sync generator
                                // å¦‚æœ worker æœªç”Ÿæˆæœ‰æ•ˆåœ°å›¾ï¼Œå›é€€åˆ°ä¸»çº¿ç¨‹ç”Ÿæˆå™¨
                                if (typeof this.generateWinnableMapReverse === 'function') {
                                        const fallback = this.generateWinnableMapReverse(options) || [];
                                    applyObstacles(fallback);
                                    if (spinner) spinner.style.display = 'none';
                                    resolve(fallback);
                                } else {
                                    applyObstacles([]);
                                    if (spinner) spinner.style.display = 'none';
                                    resolve([]);
                                }
                            } else {
                                applyObstacles(obstacles);
                                if (spinner) spinner.style.display = 'none';
                                resolve(obstacles);
                            }
                            return;
                        }

                        if (d.type === 'error') {
                            // worker error
                            if (spinner) spinner.style.display = 'none';
                            worker.removeEventListener('message', handler);
                            // å›é€€åˆ°åŒæ­¥ç”Ÿæˆå™¨
                            if (typeof this.generateWinnableMapReverse === 'function') {
                                const fallback = this.generateWinnableMapReverse(options) || [];
                                applyObstacles(fallback);
                                if (spinner) spinner.style.display = 'none';
                                resolve(fallback);
                            } else {
                                applyObstacles([]);
                                if (spinner) spinner.style.display = 'none';
                                resolve([]);
                            }
                        }
                    };

                    worker.addEventListener('message', handler);
                    try {
                        worker.postMessage({ cmd: 'generate', options, rowsLayout: ROWS_LAYOUT, boardCols: BOARD_COLS, requestId });
                    } catch (err) {
                        // Worker postMessage failed, falling back to sync generator
                        worker.removeEventListener('message', handler);
                        if (typeof this.generateWinnableMapReverse === 'function') {
                            const fallback = this.generateWinnableMapReverse(options) || [];
                            applyObstacles(fallback);
                            if (spinner) spinner.style.display = 'none';
                            resolve(fallback);
                        } else {
                            applyObstacles([]);
                            if (spinner) spinner.style.display = 'none';
                            resolve([]);
                        }
                    }
                    return;
                }

                // æ—  Workerï¼šåŒæ­¥ç”Ÿæˆï¼ˆå›é€€ï¼‰
                let obstaclesToUse = [];
                if (typeof this.generateWinnableMapReverse === 'function') {
                    const generated = this.generateWinnableMapReverse(options);
                    if (generated && generated.length) {
                        obstaclesToUse = generated;
                    } else {
                        // generator failed to produce a valid map
                        obstaclesToUse = [];
                    }
                }

                applyObstacles(obstaclesToUse);
                if (document.getElementById('genSpinner')) document.getElementById('genSpinner').style.display = 'none';
                resolve(obstaclesToUse);
                });
            }
            
            createAxialMapping() {
                this.indexToAxial.clear();
                this.axialToIndex.clear();
                
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            const q = c - Math.floor(r / 2);
                            const axialR = r;
                            this.indexToAxial.set(`${r},${c}`, [q, axialR]);
                            this.axialToIndex.set(`${q},${axialR}`, [r, c]);
                        }
                    }
                }
                // æ›´æ–°ç»˜åˆ¶åç§»ï¼ˆè‹¥éœ€è¦ï¼Œå¯ä»¥åœ¨ draw å‰å†æ¬¡è®¡ç®—ä»¥é€‚åº” canvas å°ºå¯¸å˜åŒ–ï¼‰
                this._boardOffset = this._boardOffset || null;
            }

            computeBoardOffset() {
                const CELL_SIZE = 40;
                const Y_SPACING = CELL_SIZE * 0.85;
                const coords = [];
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            const x = (c - BOARD_COLS / 2) * CELL_SIZE + (r % 2) * (CELL_SIZE / 2);
                            const y = r * Y_SPACING;
                            coords.push([x, y]);
                        }
                    }
                }
                if (!coords.length) {
                    this._boardOffset = { x: this.canvas.width / 2, y: 120 };
                    return;
                }
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const [x, y] of coords) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
                const boardCenterX = (minX + maxX) / 2;
                const boardCenterY = (minY + maxY) / 2;
                const canvasCenterX = this.canvas.width / 2;
                const canvasCenterY = this.canvas.height / 2;
                this._boardOffset = { x: canvasCenterX - boardCenterX, y: canvasCenterY - boardCenterY };
            }

            regenerateMap() {
                return this.setupBoard();
            }

            // ç”Ÿæˆä¸€ä¸ªä¿è¯å¯èƒœåˆ©çš„åœ°å›¾ï¼ˆåå‘æ„é€ è·¯å¾„ï¼‰
            // è¿”å›ï¼šé€»è¾‘åæ ‡æ•°ç»„ [[rowNo,posNo,color], ...]ï¼Œè‹¥ç”Ÿæˆå¤±è´¥è¿”å› []
            generateWinnableMapReverse(options = {}) {
                // DFS/backtracking reverse path generator
                // generateWinnableMapReverse called
                const maxSteps = options.maxSteps || 12;
                const maxAttempts = options.maxAttempts || 200;
                const minDirChanges = (typeof options.minDirChanges === 'number') ? options.minDirChanges : 2;
                const maxStraight = (typeof options.maxStraight === 'number') ? options.maxStraight : 2;
                const allowLongJumps = !!options.allowLongJumps;

                const pickColor = () => ['#A020F0','#3282FF','#FF69B4','#FFD700','#FF8C00','#DC143C'][Math.floor(Math.random()*6)];

                const shuffle = (arr) => {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                };

                const indexToLogical = (r, c) => {
                    const rowNo = r + 1;
                    const count = ROWS_LAYOUT[r];
                    const offset = Math.floor((BOARD_COLS - count) / 2);
                    const posNo = (c - offset) + 1;
                    return [rowNo, posNo];
                };

                // backup and use an empty board for search
                const oldBoard = this.board;
                const oldBoardColors = this.boardColors;
                const oldIndexToAxial = new Map(this.indexToAxial);
                const oldAxialToIndex = new Map(this.axialToIndex);

                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                this.createAxialMapping();

                const startIdx = this.logicalToIndex(17, 1);
                if (!startIdx) {
                    this.board = oldBoard; this.boardColors = oldBoardColors; this.indexToAxial = oldIndexToAxial; this.axialToIndex = oldAxialToIndex; return [];
                }
                const startAxial = this.indexToAxial.get(`${startIdx[0]},${startIdx[1]}`);
                if (!startAxial) { this.board = oldBoard; this.boardColors = oldBoardColors; this.indexToAxial = oldIndexToAxial; this.axialToIndex = oldAxialToIndex; return []; }

                const victoryCells = [];
                for (let r = 0; r <= 3 && r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) if (this.board[r][c] !== INVALID) victoryCells.push([r,c]);
                }

                const dirsAll = AXIAL_DIRS.slice();

                // recursive DFS: try to reach startAxial from (qCur,rCur)
                const tryFromTarget = (targetQ, targetR) => {
                    const visited = new Set();
                    const pathMid = [];
                    const dirsTaken = [];

                    const dfs = (qCur, rCur, depth, lastDir, straightCount) => {
                        if (depth > maxSteps) return false;
                        const curKey = `${qCur},${rCur}`;
                        const startKey = `${startAxial[0]},${startAxial[1]}`;
                        if (curKey === startKey) {
                            return true;
                        }

                        // build candidate directions, shuffle for randomness
                        let candidates = dirsAll.slice();
                        shuffle(candidates);

                        for (const d of candidates) {
                            const dq = d[0], dr = d[1];
                            const prevQ = qCur + dq * 2;
                            const prevR = rCur + dr * 2;
                            const midQ = qCur + dq;
                            const midR = rCur + dr;
                            const prevKey = `${prevQ},${prevR}`;
                            const midKey = `${midQ},${midR}`;

                            if (visited.has(prevKey)) continue;
                            if (!this.axialToIndex.has(prevKey) || !this.axialToIndex.has(midKey)) continue;
                            const [prevRi, prevCi] = this.axialToIndex.get(prevKey);
                            const [midRi, midCi] = this.axialToIndex.get(midKey);
                            if (this.board[prevRi][prevCi] !== EMPTY) continue;
                            if (this.board[midRi][midCi] !== EMPTY) continue;

                            // enforce straight constraint
                            let newStraight = 1;
                            if (lastDir && d[0] === lastDir[0] && d[1] === lastDir[1]) newStraight = straightCount + 1;
                            if (newStraight > maxStraight) continue;

                            // mark and descend
                            visited.add(prevKey);
                            const [rowNo, posNo] = indexToLogical(midRi, midCi);
                            pathMid.push([rowNo, posNo, pickColor()]);
                            dirsTaken.push(d);

                            if (dfs(prevQ, prevR, depth+1, d, newStraight)) return true;

                            // backtrack
                            visited.delete(prevKey);
                            pathMid.pop();
                            dirsTaken.pop();
                        }
                        return false;
                    };

                    const ok = dfs(targetQ, targetR, 0, null, 0);
                    if (ok) {
                        const dirChanges = dirsTaken.length > 0 ? dirsTaken.reduce((acc,_,i,arr) => { if (i===0) return 0; return acc + ((arr[i][0]!==arr[i-1][0] || arr[i][1]!==arr[i-1][1])?1:0); },0) : 0;
                        if (dirChanges < minDirChanges) return null;
                        return pathMid.slice();
                    }
                    return null;
                };

                let attempts = 0;
                while (attempts < maxAttempts) {
                    attempts++;
                    const [tR,tC] = victoryCells[Math.floor(Math.random()*victoryCells.length)];
                    const tAxial = this.indexToAxial.get(`${tR},${tC}`);
                    if (!tAxial) continue;
                    const res = tryFromTarget(tAxial[0], tAxial[1]);
                    if (res && res.length) {
                        // generateWinnableMapReverse success
                        // restore and return
                        this.board = oldBoard; this.boardColors = oldBoardColors; this.indexToAxial = oldIndexToAxial; this.axialToIndex = oldAxialToIndex;
                        return res;
                    }
                }
                // generateWinnableMapReverse finished without result
                this.board = oldBoard; this.boardColors = oldBoardColors; this.indexToAxial = oldIndexToAxial; this.axialToIndex = oldAxialToIndex;
                return [];
            }
            
            isInside(r, c) {
                return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS && this.board[r][c] !== INVALID;
            }
            
            canJumpTo(startR, startC, targetR, targetC) {
                if (!this.isInside(startR, startC) || !this.isInside(targetR, targetC)) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (this.board[startR][startC] !== PLAYER) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (this.board[targetR][targetC] !== EMPTY) {
                    return {valid: false, obstaclePos: null};
                }
                
                const startKey = `${startR},${startC}`;
                const targetKey = `${targetR},${targetC}`;
                
                if (!this.indexToAxial.has(startKey) || !this.indexToAxial.has(targetKey)) {
                    return {valid: false, obstaclePos: null};
                }
                
                const [q1, r1] = this.indexToAxial.get(startKey);
                const [q2, r2] = this.indexToAxial.get(targetKey);
                
                const dq = q2 - q1;
                const dr = r2 - r1;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å…­æ–¹å‘çš„æ•´æ•°å€
                let directionFound = false;
                let dirQ = 0, dirR = 0;
                let factor = 0;
                
                for (const [testDirQ, testDirR] of AXIAL_DIRS) {
                    if (dq === 0 && testDirQ === 0) {
                        if (dr !== 0 && dr % testDirR === 0) {
                            factor = dr / testDirR;
                            if (factor > 0) {
                                directionFound = true;
                                dirQ = testDirQ;
                                dirR = testDirR;
                                break;
                            }
                        }
                    } else if (dr === 0 && testDirR === 0) {
                        if (dq !== 0 && dq % testDirQ === 0) {
                            factor = dq / testDirQ;
                            if (factor > 0) {
                                directionFound = true;
                                dirQ = testDirQ;
                                dirR = testDirR;
                                break;
                            }
                        }
                    } else if (dq !== 0 && dr !== 0) {
                        if (dq * testDirR === dr * testDirQ) {
                            if (testDirQ !== 0 && dq % testDirQ === 0) {
                                const testFactor = dq / testDirQ;
                                if (testFactor > 0 && dr === testDirR * testFactor) {
                                    directionFound = true;
                                    dirQ = testDirQ;
                                    dirR = testDirR;
                                    factor = testFactor;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (!directionFound) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (factor % 2 !== 0 || factor < 2) {
                    return {valid: false, obstaclePos: null};
                }
                
                // éšœç¢ç‰©åº”è¯¥åœ¨ä¸­é—´ä½ç½®
                const obstacleFactor = factor / 2;
                const obstacleQ = q1 + dirQ * obstacleFactor;
                const obstacleR = r1 + dirR * obstacleFactor;
                const obstacleKey = `${obstacleQ},${obstacleR}`;
                
                if (!this.axialToIndex.has(obstacleKey)) {
                    return {valid: false, obstaclePos: null};
                }
                
                const [obstacleRIdx, obstacleCIdx] = this.axialToIndex.get(obstacleKey);
                
                if (this.board[obstacleRIdx][obstacleCIdx] !== OBSTACLE) {
                    return {valid: false, obstaclePos: null};
                }
                
                // æ£€æŸ¥è·¯å¾„æ˜¯å¦ç•…é€š
                for (let i = 1; i < factor; i++) {
                    if (i === obstacleFactor) continue;
                    
                    const pathQ = q1 + dirQ * i;
                    const pathR = r1 + dirR * i;
                    const pathKey = `${pathQ},${pathR}`;
                    
                    if (!this.axialToIndex.has(pathKey)) {
                        return {valid: false, obstaclePos: null};
                    }
                    
                    const [pathRIdx, pathCIdx] = this.axialToIndex.get(pathKey);
                    
                    if (this.board[pathRIdx][pathCIdx] !== EMPTY) {
                        return {valid: false, obstaclePos: null};
                    }
                }
                
                return {valid: true, obstaclePos: [obstacleRIdx, obstacleCIdx]};
            }
            
            findAllJumpsFrom(startR, startC) {
                if (!this.isInside(startR, startC) || this.board[startR][startC] !== PLAYER) {
                    return [];
                }
                
                const possibleJumps = [];
                
                // æ£€æŸ¥æ‰€æœ‰æ–¹å‘å’Œè·ç¦»
                for (const [dirQ, dirR] of AXIAL_DIRS) {
                    for (const factor of [2, 4, 6, 8]) {
                        const startKey = `${startR},${startC}`;
                        const [q1, r1] = this.indexToAxial.get(startKey);
                        const targetQ = q1 + dirQ * factor;
                        const targetR = r1 + dirR * factor;
                        const targetKey = `${targetQ},${targetR}`;
                        
                        if (!this.axialToIndex.has(targetKey)) continue;
                        
                        const [targetRIdx, targetCIdx] = this.axialToIndex.get(targetKey);
                        
                        const {valid} = this.canJumpTo(startR, startC, targetRIdx, targetCIdx);
                        if (valid) {
                            possibleJumps.push([targetRIdx, targetCIdx]);
                        }
                    }
                }
                
                return possibleJumps;
            }
            
            makeJump(fr, fc, tr, tc) {
                const {valid, obstaclePos} = this.canJumpTo(fr, fc, tr, tc);
                if (!valid || !obstaclePos) {
                    return false;
                }
                
                const [or_, oc] = obstaclePos;
                
                // ä¿å­˜å½“å‰çŠ¶æ€
                this.saveState();
                
                // èµ·ç‚¹æ¸…ç©º
                this.board[fr][fc] = EMPTY;
                
                // ä¸­é—´éšœç¢ç‰©è¢«åƒæ‰
                this.board[or_][oc] = EMPTY;
                this.boardColors[or_][oc] = null;
                this.remainingPieces--;
                
                // ç»ˆç‚¹å˜æˆç©å®¶
                this.board[tr][tc] = PLAYER;
                this.playerPos = [tr, tc];
                
                // å¢åŠ æ­¥æ•°
                this.moveCount++;
                
                // é‡æ–°åˆ›å»ºåæ ‡æ˜ å°„
                this.createAxialMapping();
                
                // æ’­æ”¾åƒå­éŸ³æ•ˆ
                this.playCaptureSound();
                
                // æ£€æŸ¥èƒœåˆ©
                if (this.checkWin()) {
                    this.playVictorySound();
                    return true;
                }
                
                return true;
            }
            
            checkWin() {
                if (!this.playerPos) return false;
                
                const [r, c] = this.playerPos;
                // å‰4è¡Œï¼ˆçŸ©é˜µè¡Œ0-3ï¼‰æ˜¯èƒœåˆ©åŒºåŸŸ
                if (r <= 3 && this.board[r][c] === PLAYER) {
                    this.gameWon = true;
                    document.getElementById('victoryMessage').style.display = 'block';
                    return true;
                }
                
                this.gameWon = false;
                return false;
            }
            
            saveState() {
                const state = {
                    board: this.board.map(row => [...row]),
                    boardColors: this.boardColors.map(row => [...row]),
                    playerPos: this.playerPos ? [...this.playerPos] : null,
                    moveCount: this.moveCount,
                    remainingPieces: this.remainingPieces
                };
                this.history.push(state);
                
                // é™åˆ¶å†å²è®°å½•é•¿åº¦
                if (this.history.length > 20) {
                    this.history.shift();
                }
            }
            
            undo() {
                if (this.history.length > 1) {
                    this.history.pop(); // ç§»é™¤å½“å‰çŠ¶æ€
                    
                    // æ¢å¤åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€
                    const prevState = this.history[this.history.length - 1];
                    
                    this.board = prevState.board.map(row => [...row]);
                    this.boardColors = prevState.boardColors.map(row => [...row]);
                    this.playerPos = prevState.playerPos ? [...prevState.playerPos] : null;
                    this.moveCount = prevState.moveCount;
                    this.remainingPieces = prevState.remainingPieces;
                    this.selected = null;
                    
                    // é‡æ–°åˆ›å»ºåæ ‡æ˜ å°„
                    this.createAxialMapping();
                    
                    // éšè—èƒœåˆ©æ¶ˆæ¯
                    document.getElementById('victoryMessage').style.display = 'none';
                    this.gameWon = false;
                    
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            restart() {
                // é‡ç½®ä¸ºå½“å‰åœ°å›¾çš„åˆå§‹å¯¹å±€çŠ¶æ€ï¼ˆä½¿ç”¨ history[0]ï¼‰
                if (this.history && this.history.length > 0) {
                    const initState = this.history[0];
                    this.board = initState.board.map(row => [...row]);
                    this.boardColors = initState.boardColors.map(row => [...row]);
                    this.playerPos = initState.playerPos ? [...initState.playerPos] : null;
                    this.moveCount = initState.moveCount || 0;
                    this.remainingPieces = initState.remainingPieces || 0;
                    this.selected = null;
                    this.gameWon = false;
                    // é‡æ–°åˆ›å»ºåæ ‡æ˜ å°„å¹¶ç»˜åˆ¶
                    this.createAxialMapping();
                    // é‡ç½®å†å²ä¸ºä»…æœ‰åˆå§‹çŠ¶æ€
                    this.history = [
                        {
                            board: this.board.map(row => [...row]),
                            boardColors: this.boardColors.map(row => [...row]),
                            playerPos: this.playerPos ? [...this.playerPos] : null,
                            moveCount: this.moveCount,
                            remainingPieces: this.remainingPieces
                        }
                    ];
                    // éšè—èƒœåˆ©æ¶ˆæ¯
                    const vmsg = document.getElementById('victoryMessage'); if (vmsg) vmsg.style.display = 'none';
                    this.updateUI();
                    this.draw();
                    return;
                }

                // å¦‚æœæ²¡æœ‰å·²ä¿å­˜çš„åœ°å›¾ï¼ˆæç«¯æƒ…å†µï¼‰ï¼Œé€€å›åˆ°å®Œæ•´é‡ç½®å¹¶ç”Ÿæˆæ–°åœ°å›¾
                this.initGame(false);
            }
            
            getPixelPos(row, col) {
                const CELL_SIZE = 40;
                const Y_SPACING = CELL_SIZE * 0.85;
                const baseX = (col - BOARD_COLS / 2) * CELL_SIZE + (row % 2) * (CELL_SIZE / 2);
                const baseY = row * Y_SPACING;
                const off = this._boardOffset || { x: this.canvas.width / 2, y: 120 };
                return [off.x + baseX, off.y + baseY];
            }
            
            getBoardPos(px, py) {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] === INVALID) continue;
                        
                        const [x, y] = this.getPixelPos(r, c);
                        const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                        
                        if (distance < 20) {
                            return [r, c];
                        }
                    }
                }
                return null;
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // é‡æ–°è®¡ç®—åç§»ä»¥ä¿è¯åœ¨ canvas å°ºå¯¸æ›´æ”¹æ—¶ä»å±…ä¸­
                this.computeBoardOffset();
                
                // ç»˜åˆ¶èƒœåˆ©åŒºåŸŸèƒŒæ™¯ï¼ˆå‰4è¡Œï¼‰
                for (let r = 0; r < Math.min(4, BOARD_ROWS); r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            const [x, y] = this.getPixelPos(r, c);
                            
                            // åˆ›å»ºå¾„å‘æ¸å˜
                            const gradient = this.ctx.createRadialGradient(x, y, 5, x, y, 25);
                            gradient.addColorStop(0, 'rgba(144, 238, 144, 0.6)');
                            gradient.addColorStop(1, 'rgba(144, 238, 144, 0.1)');
                            
                            this.ctx.beginPath();
                            this.ctx.fillStyle = gradient;
                            this.ctx.arc(x, y, 23, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // ç»˜åˆ¶æ£‹ç›˜å’Œæ£‹å­
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] === INVALID) continue;
                        
                        const [x, y] = this.getPixelPos(r, c);
                        let color;
                        
                        if (this.board[r][c] === EMPTY) {
                            color = COLORS.EMPTY;
                        } else if (this.board[r][c] === OBSTACLE) {
                            color = this.boardColors[r][c] || '#aaaaaa';
                        } else if (this.board[r][c] === PLAYER) {
                            color = COLORS.PLAYER;
                        } else {
                            color = COLORS.EMPTY;
                        }
                        
                        // é€‰ä¸­æ£‹å­é«˜äº®è¾¹æ¡†
                        if (this.selected && this.selected[0] === r && this.selected[1] === c) {
                            this.ctx.beginPath();
                            this.ctx.fillStyle = COLORS.SELECTED;
                            this.ctx.arc(x, y, 20, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // ç»˜åˆ¶æ£‹å­
                        this.ctx.beginPath();
                        this.ctx.fillStyle = color;
                        this.ctx.arc(x, y, 17, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // æ·»åŠ æ£‹å­è¾¹æ¡†
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        this.ctx.lineWidth = 1;
                        this.ctx.arc(x, y, 17, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // åœ¨ç©å®¶æ£‹å­ä¸Šç”»ä¸€ä¸ªç™½ç‚¹
                        if (this.board[r][c] === PLAYER) {
                            this.ctx.beginPath();
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }

                // å·²ç§»é™¤è·¯å¾„é«˜äº®åŠŸèƒ½ â€” ä¸å†ç»˜åˆ¶ç”Ÿæˆè·¯å¾„ç´¢å¼•
                
                // æ˜¾ç¤ºå¯è·³ç›®æ ‡ï¼ˆå…¨éƒ¨æ˜¾ç¤ºä¸ºç»¿è‰²ï¼‰
                if (this.selected) {
                    const [fr, fc] = this.selected;
                    if (this.board[fr][fc] === PLAYER) {
                        const possibleJumps = this.findAllJumpsFrom(fr, fc);
                        for (const [tr, tc] of possibleJumps) {
                            const [hx, hy] = this.getPixelPos(tr, tc);
                            
                            this.ctx.beginPath();
                            this.ctx.fillStyle = COLORS.HIGHLIGHT;
                            this.ctx.arc(hx, hy, 12, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // æ·»åŠ è¾¹æ¡†
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = '#00A844';
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(hx, hy, 12, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
            }
            
            playCaptureSound() {
                // åˆ›å»ºç®€å•çš„åƒå­éŸ³æ•ˆ
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (e) {
                    // audio context unavailable; silently ignore
                }
            }
            
            playVictorySound() {
                // åˆ›å»ºç®€å•çš„èƒœåˆ©éŸ³æ•ˆ
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // æ’­æ”¾ä¸€ä¸ªèƒœåˆ©å’Œå¼¦
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                            oscillator.frequency.value = notes[i];
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.5);
                        }, i * 150);
                    }
                } catch (e) {
                    // audio context unavailable; silently ignore
                }
            }
            
            updateUI() {
                document.getElementById('moveCount').textContent = this.moveCount;
                document.getElementById('remainingPieces').textContent = this.remainingPieces;
            }
            
            setupEventListeners() {
                // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameWon) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const cell = this.getBoardPos(x, y);
                    if (!cell) {
                        this.selected = null;
                        this.draw();
                        return;
                    }
                    
                    const [r, c] = cell;
                    
                    // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šåªèƒ½é€‰ç©å®¶æ£‹å­
                    if (this.selected === null) {
                        if (this.board[r][c] === PLAYER) {
                            this.selected = [r, c];
                        }
                    } else {
                        const [fr, fc] = this.selected;
                        // å†æ¬¡ç‚¹å‡»ï¼šå°è¯•è·³è·ƒ
                        if (!(r === fr && c === fc)) {
                            const success = this.makeJump(fr, fc, r, c);
                            if (success) {
                                this.updateUI();
                            }
                            this.selected = null;
                        } else {
                            this.selected = null;
                        }
                    }
                    
                    this.draw();
                });
                
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                        this.draw();
                    } else if (e.ctrlKey && e.key === 'r') {
                        e.preventDefault();
                        this.restart();
                    } else if (e.key === 'Escape') {
                        this.selected = null;
                        this.draw();
                    }
                });
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('undoBtn').addEventListener('click', () => {
                    this.undo();
                    this.draw();
                });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
                // åœ°å›¾ä¸‹æ‹‰å·²ç§»é™¤
            }
        }
        
        // -----------------------------------------------------
        // åˆå§‹åŒ–æ¸¸æˆ
        // -----------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            // åˆ›å»ºç”Ÿæˆå™¨ Workerï¼ˆå¤–éƒ¨æ–‡ä»¶ï¼‰
            try {
                const genWorker = new Worker('generatorWorker.js');
                genWorker.addEventListener('message', (e) => {});
                genWorker.addEventListener('error', (err) => {});
                window.genWorker = genWorker;
            } catch (err) {
                window.genWorker = null;
            }
            // åœ°å›¾ä¸‹æ‹‰å·²ç§»é™¤ï¼›å§‹ç»ˆä½¿ç”¨ç”Ÿæˆå™¨ç”Ÿæˆåœ°å›¾

            // é“¾æ¥éš¾åº¦æ»‘å—æ˜¾ç¤º
            const diffRange = document.getElementById('difficultyRange');
            const diffValue = document.getElementById('difficultyValue');
            if (diffRange && diffValue) {
                diffValue.textContent = diffRange.value;
                diffRange.addEventListener('input', () => { diffValue.textContent = diffRange.value; });
            }

            const game = new Game();

            // æ·»åŠ å‚æ•°é¢æ¿ï¼ˆç®€å•å®ç°ï¼‰
            const panelHtml = `
                <h3 style="margin-top:0;margin-bottom:8px;">ç”Ÿæˆå™¨å‚æ•°</h3>
                <div style="display:grid;gap:8px;">
                    <label style="display:flex;align-items:center;gap:8px;">éš¾åº¦ï¼š<input id="difficultyRange" type="range" min="1" max="5" value="3" style="width:120px;"> <span id="difficultyValue">3</span></label>
                    <label>maxSteps: <input id="opt_maxSteps" type="number" min="4" max="48" value="12" style="width:100%;"></label>
                    <label>maxAttempts: <input id="opt_maxAttempts" type="number" min="50" max="2000" value="200" style="width:100%;"></label>
                    <label>minDirChanges: <input id="opt_minDirChanges" type="number" min="1" max="6" value="1" style="width:100%;"></label>
                    <label>maxStraight: <input id="opt_maxStraight" type="number" min="1" max="6" value="2" style="width:100%;"></label>
                    <label>decorationDensity: <input id="opt_decorationDensity" type="number" step="0.01" min="0" max="0.2" value="0.04" style="width:100%;"></label>
                    <label style="display:flex;align-items:center;gap:8px;"><input id="opt_allowLongJumps" type="checkbox"> å…è®¸é•¿è·³</label>
                </div>
                <div style="display:flex;gap:8px;margin-top:10px;">
                    <button id="panelApplyBtn" style="flex:1;">åº”ç”¨</button>
                    <button id="panelResetBtn" style="flex:1;">å¿«é€Ÿé‡ç½®</button>
                </div>
            `;
            const panel = document.createElement('div');
            panel.className = 'panel';
            panel.innerHTML = panelHtml;
            // å°†é¢æ¿ä¸ container æ”¾å…¥åŒä¸€æ°´å¹³è¡Œå¹¶å±…ä¸­æ˜¾ç¤º
            const oldContainer = document.querySelector('.container');
            const layoutRow = document.createElement('div');
            layoutRow.className = 'layout-row';
            if (oldContainer && oldContainer.parentNode) {
                oldContainer.parentNode.insertBefore(layoutRow, oldContainer);
                layoutRow.appendChild(panel);
                layoutRow.appendChild(oldContainer);
            } else {
                // è‹¥ä¸å­˜åœ¨ containerï¼Œåˆ™å°† panel å•ç‹¬æ’å…¥
                document.body.insertBefore(panel, document.body.firstChild);
            }

            // é»˜è®¤ applied options
            window.appliedGeneratorOptions = null;

            const collectOptionsFromPanel = () => {
                const get = (id, parseFn, fallback) => { const el = document.getElementById(id); if (!el) return fallback; const v = el.value; return parseFn ? parseFn(v) : v; };
                const opts = {
                    maxSteps: get('opt_maxSteps', v=>parseInt(v,10), 12),
                    maxAttempts: get('opt_maxAttempts', v=>parseInt(v,10), 200),
                    minDirChanges: get('opt_minDirChanges', v=>parseInt(v,10), 1),
                    maxStraight: get('opt_maxStraight', v=>parseInt(v,10), 2),
                    decorationDensity: get('opt_decorationDensity', v=>parseFloat(v), 0.04),
                    allowLongJumps: document.getElementById('opt_allowLongJumps') ? document.getElementById('opt_allowLongJumps').checked : false
                };
                return opts;
            };

            // Apply / Reset bindings
            const applyBtn = document.getElementById('panelApplyBtn');
            const resetBtn = document.getElementById('panelResetBtn');
            const applyDefaults = () => {
                document.getElementById('opt_maxSteps').value = 12;
                document.getElementById('opt_maxAttempts').value = 200;
                document.getElementById('opt_minDirChanges').value = 1;
                document.getElementById('opt_maxStraight').value = 2;
                document.getElementById('opt_decorationDensity').value = 0.04;
                document.getElementById('opt_allowLongJumps').checked = false;
            };
            applyDefaults();

            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    window.appliedGeneratorOptions = collectOptionsFromPanel();
                    // åº”ç”¨ä½†ä¸ç”Ÿæˆ
                    showToast('å‚æ•°å·²åº”ç”¨ï¼ˆè¯·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆåœ°å›¾â€ï¼‰', { type: 'info', duration: 1800 });
                });
            }
            if (resetBtn) {
                // å°† panelResetBtn çš„è¡Œä¸ºè®¾ä¸ºâ€œä¿å­˜å½“å‰å‚æ•°ä»¥ç”Ÿæˆåœ°å›¾"
                resetBtn.addEventListener('click', () => {
                    window.appliedGeneratorOptions = collectOptionsFromPanel();
                    showToast('å‚æ•°å·²ä¿å­˜ï¼ˆè¯·ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆåœ°å›¾â€ï¼‰', { type: 'info', duration: 1600 });
                });
            }
            // åˆå§‹åŒ–å½“å‰ regen toast id
            window.currentRegenToastId = null;

            // ç»‘å®šé‡æ–°ç”ŸæˆæŒ‰é’®ï¼ˆä½¿ç”¨å·²åº”ç”¨çš„å‚æ•°ï¼‰
            const regenBtn = document.getElementById('regenBtn');
            if (regenBtn) {
                regenBtn.addEventListener('click', async () => {
                    try {
                        regenBtn.disabled = true;
                        const toastId = showToast('æ­£åœ¨ç”Ÿæˆæ–°åœ°å›¾', { type: 'info', persist: true });
                        window.currentRegenToastId = toastId;
                        // ä½¿ç”¨å…¨å±€ appliedGeneratorOptionsï¼ˆé€šè¿‡é¢æ¿çš„â€œåº”ç”¨â€è®¾ç½®ï¼‰
                        const opts = window.appliedGeneratorOptions || null;
                        await game.regenerateMap(opts);
                        if (toastId) hideToast(toastId);
                        showToast('åœ°å›¾å·²ç”Ÿæˆ', { type: 'success', duration: 2600 });
                    } catch (err) {
                        if (window.currentRegenToastId) hideToast(window.currentRegenToastId);
                        showToast('ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•', { type: 'error', duration: 3200 });
                    } finally {
                        regenBtn.disabled = false;
                        window.currentRegenToastId = null;
                    }
                });
            }
            // removed quickResetBtn: no control-level quick reset per request
        });
    </script>
</body>
</html>